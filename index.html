<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Heuksan — 정직하게 플레이</title>
  <meta name="description" content="정직하게 플레이하면 치트는 필요 없습니다. Heuksan#2771" />
  <meta property="og:title" content="Heuksan — 정직하게 플레이" />
  <meta property="og:description" content="정직하게 플레이하면 치트는 필요 없습니다." />
  <meta name="theme-color" content="#0b0f15" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0b0f15;
      --card: #121826cc; /* glassy */
      --text: #e5ecf5;
      --muted: #9fb0c3;
      --accent: #7aa2ff;
      --accent-2: #00ffd9;
      --ring: 0 0 0 4px color-mix(in oklab, var(--accent) 40%, transparent);
      --radius: 22px;
      --shadow: 0 10px 30px rgba(0,0,0,0.45), 0 2px 8px rgba(0,0,0,0.35);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: 'Noto Sans KR', system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:
        radial-gradient(1200px 1200px at 10% 10%, rgba(42,63,107,.25), transparent 60%),
        radial-gradient(1000px 1000px at 90% 20%, rgba(10,180,155,.18), transparent 60%),
        radial-gradient(800px 800px at 50% 100%, rgba(100,120,255,.14), transparent 60%),
        var(--bg);
      color: var(--text);
      display: grid;
      place-items: center;
      overflow: hidden;
    }
    .grid {
      width: min(960px, 92vw);
      display: grid;
      gap: 28px;
      grid-template-columns: 1fr;
      padding: 32px;
    }
    .card {
      position: relative;
      padding: clamp(28px, 6vw, 56px);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(19,25,37,.85), rgba(12,16,24,.75));
      border: 1px solid rgba(131,151,199, .18);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px) saturate(120%);
      isolation: isolate;
    }
    .ring { position: absolute; inset: -1px; border-radius: inherit; pointer-events: none; }
    .ring::before {
      content: ""; position: absolute; inset: -1px; border-radius: inherit;
      background: conic-gradient(from 0deg,
        color-mix(in oklab, var(--accent) 80%, transparent) 0deg,
        color-mix(in oklab, var(--accent-2) 80%, transparent) 120deg,
        transparent 180deg,
        transparent 360deg);
      filter: blur(24px) saturate(160%);
      opacity: .28;
      transition: opacity .35s ease;
    }
    .card:hover .ring::before { opacity: .5; }

    header {
      display: flex; align-items: center; justify-content: space-between;
      gap: 16px; margin-bottom: 20px;
    }
    .tag {
      display: inline-flex; align-items: center; gap: 10px;
      padding: 10px 14px; border-radius: 999px;
      background: rgba(122,162,255,.12);
      border: 1px solid rgba(122,162,255,.25);
      font-weight: 600; letter-spacing: .2px;
    }
    .tag .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--accent-2); box-shadow: 0 0 14px var(--accent-2); }

    h1 {
      font-size: clamp(28px, 4.5vw, 56px);
      line-height: 1.08;
      margin: 6px 0 12px;
      font-weight: 800;
      letter-spacing: -0.02em;
      text-shadow: 0 2px 30px rgba(0,255,217,.24);
    }
    p.lead {
      font-size: clamp(16px, 2.2vw, 22px);
      color: var(--muted);
      margin: 0 0 26px;
    }

    .cta {
      display: inline-flex; align-items: center; gap: 10px;
      padding: 12px 18px; border-radius: 14px;
      border: 1px solid rgba(131,151,199,.25);
      background: linear-gradient(180deg, rgba(26,34,51,.9), rgba(17,22,35,.9));
      text-decoration: none; color: var(--text);
      font-weight: 600;
      transition: transform .12s ease, box-shadow .2s ease, border-color .2s ease;
      box-shadow: 0 6px 18px rgba(0,0,0,.35);
    }
    .cta:hover { transform: translateY(-1px); border-color: rgba(122,162,255,.45); box-shadow: 0 10px 28px rgba(0,0,0,.45); }

    .mono { font-variant-ligatures: none; font-feature-settings: "ss01" on, "ss02" on; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    footer { opacity: .7; font-size: 13px; text-align: center; }

    /* Motion safety */
    @media (prefers-reduced-motion: reduce) {
      .card:hover .ring::before { opacity: .35; }
      .cta { transition: none; }
    }
  </style>
</head>
<body>
  <main class="grid">
    <section class="card" aria-label="Heuksan 소개">
      <span class="ring" aria-hidden="true"></span>

      <header>
        <span class="tag" title="Discord 태그">
          <span class="dot" aria-hidden="true"></span>
          <span class="mono">Heuksan#2771</span>
        </span>
        <span class="mono" style="opacity:.6">dark mode</span>
      </header>

      <h1>정직하게 플레이하면<br/>치트는 필요 없습니다</h1>
      <p class="lead">공정함은 최고의 실력입니다. 누구나 즐길 수 있는 깨끗한 플레이 문화를 지지합니다.</p>

      <a class="cta" href="https://discord.com/" target="_blank" rel="noreferrer noopener" aria-label="Discord로 연결">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" role="img" aria-hidden="true" style="opacity:.9">
          <path d="M20.317 4.369a19.791 19.791 0 0 0-4.885-1.515.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.249-1.84-.276-3.68-.276-5.486 0-.164-.405-.41-.874-.62-1.249a.077.077 0 0 0-.079-.037 19.736 19.736 0 0 0-4.885 1.515.07.07 0 0 0-.032.027C2.18 9.045 1.44 13.58 1.731 18.061a.082.082 0 0 0 .031.057 19.9 19.9 0 0 0 5.993 3.03.078.078 0 0 0 .084-.027c.462-.63.874-1.295 1.226-1.994a.077.077 0 0 0-.041-.106c-.652-.249-1.273-.548-1.872-.892a.078.078 0 0 1-.008-.129c.125-.094.25-.191.37-.291a.074.074 0 0 1 .077-.01c3.927 1.793 8.18 1.793 12.061 0a.074.074 0 0 1 .079.009c.12.1.245.198.37.292a.078.078 0 0 1-.006.129 12.298 12.298 0 0 1-1.873.891.077.077 0 0 0-.041.107c.36.699.773 1.364 1.226 1.994a.077.077 0 0 0 .084.027 19.876 19.876 0 0 0 6.002-3.03.077.077 0 0 0 .031-.056c.5-6.915-.838-11.422-3.548-13.666a.061.061 0 0 0-.031-.028Zm-12.12 9.859c-1.183 0-2.157-1.09-2.157-2.432 0-1.34.954-2.433 2.157-2.433 1.213 0 2.177 1.102 2.157 2.433 0 1.342-.954 2.432-2.157 2.432Zm7.623 0c-1.183 0-2.157-1.09-2.157-2.432 0-1.34.954-2.433 2.157-2.433 1.213 0 2.177 1.102 2.157 2.433 0 1.342-.944 2.432-2.157 2.432Z"/>
        </svg>
        <span>Discord에서 연락하기</span>
      </a>
    </section>

    <section class="card" aria-label="계정 상태 확인" style="display:flex;flex-direction:column;gap:18px;">
      <h2 style="margin:0;font-size:20px;font-weight:700">계정 상태 확인</h2>
      <p class="lead" style="margin:0">직접 Blizzard/Battle.net에서 계정 상태를 확인할 수 있도록 바로가기와 간단한 안내를 제공합니다. 저는 사용자의 계정에 직접 접속하거나 추적할 수 없습니다. 대신 아래 기능을 사이트에 추가했습니다:</p>

      <div style="display:flex;gap:12px;flex-wrap:wrap">
        <a class="cta" href="https://account.battle.net" target="_blank" rel="noreferrer noopener" aria-label="Battle.net 계정으로 이동">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" role="img" aria-hidden="true" style="opacity:.9">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z"/>
          </svg>
          <span>Battle.net에서 계정 확인</span>
        </a>

        <button class="cta" id="manualStatusBtn" type="button" aria-label="내 상태 수동 표시">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" role="img" aria-hidden="true" style="opacity:.9">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z"/>
          </svg>
          <span>내 상태를 여기에 표시하기 (민감 정보 포함 금지)</span>
        </button>
      </div>

      <div id="statusDisplay" style="margin-top:6px;padding:12px;border-radius:12px;background:rgba(255,255,255,0.02);border:1px dashed rgba(131,151,199,.08);min-height:56px;display:flex;align-items:center;">
        <span style="color:var(--muted);">여기에 계정 상태가 표시됩니다. 실제 게임 로그인 정보(비밀번호, 인증코드 등)는 절대 붙여넣지 마세요.</span>
      </div>

      <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
        <label style="font-size:13px;opacity:.9">자동 갱신(웹훅/엔드포인트에서 상태 가져오기):</label>
        <input id="webhookUrl" placeholder="https://your-server.example.com/status.json" style="flex:1;padding:10px;border-radius:10px;border:1px solid rgba(131,151,199,.08);background:transparent;color:var(--text)" />
        <button class="cta" id="startWebhookBtn">시작</button>
      </div>

      <small style="opacity:.8">참고: Blizzard의 공개 API는 계정의 실시간 온라인/오프라인 상태를 제공하지 않습니다. 안전하고 합법적으로 '실제' 상태를 표시하려면 사용자가 자신의 계정으로 Battle.net에 로그인해 상태를 공개하는 별도의 서비스(예: 개인 서버가 상태를 보고하는 웹훅)를 구현해야 합니다. 아래는 두 가지 안전한 대안입니다.</small>

      <ol style="margin:.6rem 0 0 1.2rem;color:var(--muted)">
        <li>간단한 대안 — 수동 토글: 사용자가 본인이 온

    <footer>© <span id="year"></span> Heuksan. 모두가 즐기는 공정한 플레이.</footer>
  </main>

  <script>
    document.getElementById('year').textContent = new Date().getFullYear();
  </script>
  <canvas id="starsCanvas" aria-hidden="true" style="position:fixed;inset:0;pointer-events:none;z-index:20;mix-blend-mode:screen;opacity:0.95"></canvas>

  <script>
    // Red falling stars animation — respects prefers-reduced-motion
    (function(){
      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if(prefersReduced) return; // do not animate for users who prefer reduced motion

      const canvas = document.getElementById('starsCanvas');
      const ctx = canvas.getContext('2d');
      let DPR = Math.max(1, window.devicePixelRatio || 1);
      let w = 0, h = 0;
      let stars = [];
      const STAR_COUNT = 36; // default star count — tweakable

      function resize(){
        DPR = Math.max(1, window.devicePixelRatio || 1);
        w = Math.max(300, window.innerWidth);
        h = Math.max(300, window.innerHeight);
        canvas.width = Math.floor(w * DPR);
        canvas.height = Math.floor(h * DPR);
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);
      }

      function rand(min, max){ return Math.random()*(max-min)+min }

      function initStars(){
        stars = [];
        for(let i=0;i<STAR_COUNT;i++){
          const size = rand(1.6,5.2);
          stars.push({
            x: rand(0, w),
            y: rand(-h, h),
            vy: rand(30, 160) / 100, // vertical speed in px/frame-ish
            vx: rand(-10, 10) / 100,
            size: size,
            twinkle: rand(0.02,0.12),
            phase: Math.random()*Math.PI*2,
            alpha: rand(0.6,1)
          });
        }
      }

      function draw(){
        ctx.clearRect(0,0,w,h);
        for(const s of stars){
          s.phase += s.twinkle;
          const a = Math.max(0.15, s.alpha * (0.6 + 0.4*Math.sin(s.phase)));
          // glow
          const g = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.size*6);
          g.addColorStop(0, `rgba(255,60,60,${0.14*a})`);
          g.addColorStop(0.4, `rgba(255,40,40,${0.08*a})`);
          g.addColorStop(1, `rgba(0,0,0,0)`);
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.size*6, 0, Math.PI*2);
          ctx.fill();

          // core
          ctx.beginPath();
          ctx.fillStyle = `rgba(255,40,40,${a})`;
          ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
          ctx.fill();

          // update
          s.y += s.vy * (DPR*0.7);
          s.x += s.vx * (DPR*0.7);

          // reset if out
          if(s.y - s.size > h + 20){
            s.y = rand(-80, -10);
            s.x = rand(0, w);
            s.vy = rand(30, 160) / 100;
            s.size = rand(1.6,5.2);
            s.alpha = rand(0.6,1);
          }
          if(s.x < -40 || s.x > w + 40){
            s.x = (s.x < 0) ? rand(0, w) : rand(0, w);
          }
        }
      }

      let rafId = null;
      function loop(){
        draw();
        rafId = requestAnimationFrame(loop);
      }

      function start(){
        cancelAnimationFrame(rafId);
        resize();
        initStars();
        loop();
      }

      // Visibility handling to save CPU
      document.addEventListener('visibilitychange', ()=>{
        if(document.hidden){ cancelAnimationFrame(rafId); rafId = null; }
        else if(!rafId) loop();
      });

      // Resize handling
      let resizeTimeout;
      window.addEventListener('resize', ()=>{ clearTimeout(resizeTimeout); resizeTimeout = setTimeout(()=>{ resize(); initStars(); }, 120); });

      // init
      start();

      // expose simple tuning via window for dev
      window.__HeuksanStars = {
        setCount(n){ if(Number.isFinite(n)){ stars.length = 0; for(let i=0;i<Math.max(0,n);i++) stars.push({x:rand(0,w), y:rand(-h,h), vy:rand(30,160)/100, vx:rand(-10,10)/100, size:rand(1.6,5.2), twinkle:rand(0.02,0.12), phase:Math.random()*Math.PI*2, alpha:rand(0.6,1)}); }
        },
        stop(){ cancelAnimationFrame(rafId); rafId = null; ctx.clearRect(0,0,w,h); }
      };

    })();
  </script>

</body>
</html>



